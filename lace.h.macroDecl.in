@DECL_MACRO@

typedef struct _TD_##NAME {
  TASK_COMMON_FIELDS(_TD_##NAME)
  union {
    struct { @TASK_FIELDS@ } args;
    @RES_FIELD@
  } d;
} TD_##NAME;

/* If this line generates an error, please manually set the define LACE_TASKSIZE to a higher value */
typedef char assertion_failed_task_descriptor_out_of_bounds_##NAME[(sizeof(TD_##NAME)<=sizeof(Task)) ? 0 : -1];

void NAME##_WRAP(WorkerP *, Task *, TD_##NAME *);
@RTYPE@ NAME##_CALL(WorkerP *, Task * @FUN_ARGS@);
static inline @RTYPE@ NAME##_SYNC(WorkerP *, Task *);
static @RTYPE@ NAME##_SYNC_SLOW(WorkerP *, Task *);

static inline __attribute__((unused))
void NAME##_SPAWN(WorkerP *w, Task *__dq_head @FUN_ARGS@)
{
    PR_COUNTTASK(w);

    TD_##NAME *t;
    TailSplit ts;
    uint32_t head, split, newsplit;

    /* assert(__dq_head < w->end); */ /* Assuming to be true */

    t = (TD_##NAME *)__dq_head;
    t->f = &NAME##_WRAP;
    t->thief = THIEF_TASK;
    @TASK_INIT@
    compiler_barrier();

    Worker *wt = w->_public;
    if (unlikely(w->allstolen)) {
        if (wt->movesplit) wt->movesplit = 0;
        head = __dq_head - w->dq;
        ts = (TailSplit){{head,head+1}};
        wt->ts.v = ts.v;
        compiler_barrier();
        wt->allstolen = 0;
        w->split = __dq_head+1;
        w->allstolen = 0;
    } else if (unlikely(wt->movesplit)) {
        head = __dq_head - w->dq;
        split = w->split - w->dq;
        newsplit = (split + head + 2)/2;
        wt->ts.ts.split = newsplit;
        w->split = w->dq + newsplit;
        compiler_barrier();
        wt->movesplit = 0;
        PR_COUNTSPLITS(w, CTR_split_grow);
    }
}

static inline __attribute__((unused))
@RTYPE@ NAME##_NEWFRAME(WorkerP *w, Task *__dq_head @FUN_ARGS@)
{
    Task _t;
    TD_##NAME *t = (TD_##NAME *)&_t;
    t->f = &NAME##_WRAP;
    t->thief = THIEF_TASK;
    @TASK_INIT@

    lace_do_newframe(w, __dq_head, &_t);
    return @RETURN_RES@;
}

static inline __attribute__((unused))
void NAME##_TOGETHER(WorkerP *w, Task *__dq_head @FUN_ARGS@)
{
    Task _t;
    TD_##NAME *t = (TD_##NAME *)&_t;
    t->f = &NAME##_WRAP;
    t->thief = THIEF_TASK;
    @TASK_INIT@

    lace_do_together(w, __dq_head, &_t);
}

static __attribute__((noinline))
@RTYPE@ NAME##_SYNC_SLOW(WorkerP *w, Task *__dq_head)
{
    TD_##NAME *t;

    if ((w->allstolen) || (w->split > __dq_head && lace_shrink_shared(w))) {
        lace_leapfrog(w, __dq_head);
        t = (TD_##NAME *)__dq_head;
        return @RETURN_RES@;
    }

    compiler_barrier();

    Worker *wt = w->_public;
    if (wt->movesplit) {
        Task *t = w->split;
        size_t diff = __dq_head - t;
        diff = (diff + 1) / 2;
        w->split = t + diff;
        wt->ts.ts.split += diff;
        compiler_barrier();
        wt->movesplit = 0;
        PR_COUNTSPLITS(w, CTR_split_grow);
    }

    compiler_barrier();

    t = (TD_##NAME *)__dq_head;
    t->thief = THIEF_EMPTY;
    return NAME##_CALL(w, __dq_head @TASK_GET_FROM_t@);
}

static inline __attribute__((unused))
@RTYPE@ NAME##_SYNC(WorkerP *w, Task *__dq_head)
{
    /* assert (__dq_head > 0); */  /* Commented out because we assume contract */

    if (likely(0 == w->_public->movesplit)) {
        if (likely(w->split <= __dq_head)) {
            TD_##NAME *t = (TD_##NAME *)__dq_head;
            t->thief = THIEF_EMPTY;
            return NAME##_CALL(w, __dq_head @TASK_GET_FROM_t@);
        }
    }

    return NAME##_SYNC_SLOW(w, __dq_head);
}


